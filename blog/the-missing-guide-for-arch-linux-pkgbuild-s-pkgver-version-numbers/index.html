<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
<title>The missing guide for Arch Linux PKGBUILD&#x27;s pkgver() version numbers | nyanpasu64&#x27;s blog</title>



<meta property="og:title" content="The missing guide for Arch Linux PKGBUILD&#x27;s pkgver() version numbers">



<meta name="author" content="nyanpasu64">


<meta property="og:locale" content="en-US">


<meta name="description" content="Adventures in programming, DSP, and chiptune">
<meta property="og:description" content="Adventures in programming, DSP, and chiptune">



<link rel="canonical" href="https://nyanpasu64.gitlab.io/blog/the-missing-guide-for-arch-linux-pkgbuild-s-pkgver-version-numbers/">
<meta property="og:url" content="https://nyanpasu64.gitlab.io/blog/the-missing-guide-for-arch-linux-pkgbuild-s-pkgver-version-numbers/">



<meta property="og:site_name" content="nyanpasu64&#x27;s blog" />





  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2021-08-13T07:21:00-07:00">



  <link rel="prev" href="https://nyanpasu64.gitlab.io/blog/exotracker-newsletter-2-pivoting-to-snes/">





  <meta name="twitter:card" content="summary">



  <meta property="twitter:title" content="The missing guide for Arch Linux PKGBUILD&#x27;s pkgver() version numbers">








<script type="application/ld+json">
{
  "author": {
    "@type":"Person",
	  "name":"nyanpasu64",
  },
  "description": "Adventures in programming, DSP, and chiptune",
  "url": "https://nyanpasu64.gitlab.io/blog/the-missing-guide-for-arch-linux-pkgbuild-s-pkgver-version-numbers/",
  "@context":"https://schema.org",
  "@type": "BlogPosting",
  "headline": "The missing guide for Arch Linux PKGBUILD&#x27;s pkgver() version numbers"
  
    
    
      "datePublished":"2021-08-13T07:21:00-07:00",
    
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https://nyanpasu64.gitlab.io/blog/the-missing-guide-for-arch-linux-pkgbuild-s-pkgver-version-numbers/"
    },
  
}
</script>

  <link rel="stylesheet" href="https://nyanpasu64.gitlab.io/main.css">
  <link rel="stylesheet" href="https://nyanpasu64.gitlab.io/assets/css/CrimsonProital@0400070014001700.css">

  <link rel="icon" type="image/png" sizes="32x32" href="https://nyanpasu64.gitlab.io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://nyanpasu64.gitlab.io/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://nyanpasu64.gitlab.io/apple-touch-icon.png">
  <link rel="manifest" href="site.webmanifest">

  
    <link type="application/atom+xml" rel="alternate" href="https://nyanpasu64.gitlab.io/atom.xml" title="nyanpasu64&#x27;s blog" />
  

  

  
  
</head>

<body>
  
  <nav class="nav">
    <div class="nav-container">
      <a href="https://nyanpasu64.gitlab.io">
        <h2 class="nav-title">nyanpasu64&#x27;s blog</h2>
      </a>
      <ul>
        
          
            <li><a href="https://nyanpasu64.gitlab.io">Posts</a></li>
          
        
      </ul>
    </div>
  </nav>
  

  <main>
    
  <div class="post">
  	<h1 class="post-title">The missing guide for Arch Linux PKGBUILD&#x27;s pkgver() version numbers</h1>
  	<div class="post-info">
  		<span>Written by</span> nyanpasu64<br>
  		<span>on&nbsp;</span><time datetime="2021-08-13T07:21:00-07:00">August 13, 2021</time>
  	</div>
  	<div class="post-line"></div>
  	<p>Pacman's version comparison algorithm was designed over a decade ago to properly sort many categories of real-world version numbers, and is now set in stone, quirks and all. Later on, the AUR developed <code>pkgver()</code> conventions and templates which turn Git commits into version numbers that would sort properly in Pacman. But what are Pacman's requirements for sorting real-world version numbers, how does Pacman's version comparison algorithm work, and how are AUR <code>pkgver()</code> built around the algorithm?</p>
<h1 id="how-pacman-compares-versions">How Pacman compares versions</h1>
<p><code>vercmp</code> is a command-line utility which takes two string arguments and compares them using Pacman's version comparison algorithm.</p>
<p>The <code>vercmp</code> executable exposes the algorithm used by Pacman to determine whether a different package version is newer than what you have currently installed. Sadly, https://man.archlinux.org/man/vercmp.8 (as well as the pacman manpage) is inadequate and fails to explain the algorithm, only providing a few examples.</p>
<h2 id="requirements-for-comparing-versions">Requirements for comparing versions</h2>
<p>Pacman needs to compare the versions of real-world software programs and its own conventions correctly:</p>
<ul>
<li>1.0-beta &lt; 1.0 (from semver)
<ul>
<li>pacman and vercmp fail to fulfill this requirement, because it interprets <code>-beta</code> as build metadata (see <code>parseEVR()</code> <code>-release</code>).</li>
</ul>
</li>
<li>1.0beta &lt; 1.0 (Arch labels pre-release packages as 1.0beta rather than 1.0-beta)</li>
<li>1.0 &lt; 1.0.1</li>
<li>1.0.1 &lt; 1.0.2</li>
</ul>
<p>Pacman's version comparison algorithm also has incidental properties that I don't consider to be first principles. However, AUR <code>pkgver()</code> depend on certain ones to generate unusual-looking unintuitive version numbers that nonetheless sort properly in Pacman.</p>
<ul>
<li>1.0 &lt; 1.0.0 (I think they should be equal)</li>
<li>alpha &lt; beta &lt; 1.0</li>
<li>1.0 &lt; 1.0.alpha (it's strange that 1.0 &lt; 1.0.alpha &lt; 1.0.0)</li>
<li>1.0.alpha &lt; 1.0.0</li>
<li>1.0.alpha &lt; 1.0.1</li>
</ul>
<h2 id="algorithm-implementation">Algorithm implementation</h2>
<p>The algorithm is implemented in <code>alpm_pkg_vercmp()</code> in the Pacman source code (<a href="https://gitlab.archlinux.org/pacman/pacman/-/blob/master/lib/libalpm/version.c"><code>:lib/libalpm/version.c</code></a>). The file is 260 lines of code, with multiple functions dedicated to different aspects of version comparison. The algorithm is written in raw C, with <em>glorious</em> null-terminated strings, and string slicing implemented via <code>const</code>-incompatible null byte insertion. ðŸ˜¿</p>
<h3 id="epoch-version-and-release">Epoch, version, and release</h3>
<p><code>parseEVR()</code> parses Arch package versions using the format <code>[epoch:]version[-release]</code>. More specifically, all characters after the last hyphen form the release (even if there are colons afterwards), and the epoch is &quot;0&quot; unless the first non-digit is a colon. If no epoch is present, the epoch is labeled as 0.</p>
<p><code>parseEVR()</code> allows only numbers in the epoch field. It is usually absent, but can be used as a &quot;major version&quot; to ensure that newer program versions compare higher, even if the newer program's version number (stored in the version field) is <em>lower</em> than in older versions.</p>
<p>The release field is an optional location for &quot;build metadata&quot;. A version with no release field is considered equal to otherwise-identical versions with any release field, but two otherwise-identical versions with different release fields use the release field to break ties.</p>
<h3 id="comparing-versions">Comparing versions</h3>
<p>Each field is then compared using <code>rpmvercmp()</code>. Missing epochs are assumed to be 0, and missing releases are assumed to be equal to any numbered release.</p>
<p><code>rpmvercmp()</code> decomposes its input into &quot;segments&quot;, where each segment starts with 0 or more &quot;separator&quot; characters (any non-alphanumeric character), which are followed by 1 or more &quot;body&quot; characters (each body contains either alphabetic characters or numeric characters, so &quot;1a&quot; is 2 segments). The input may be terminated by a &quot;dangling&quot; segment with only separator characters and no body (but realistic version numbers will not have a dangling segment).</p>
<p>This can be modeled as the regex <code>([^a-zA-Z0-9]* ([a-zA-Z]+ | [0-9]+) )* [^a-zA-Z0-9]*</code> more or less.</p>
<p>Both inputs are split into segments (including dangling segments), starting at the beginning. The algorithm loops over segments from both inputs, starting with the first segment from each, until either input runs out of segments entirely (one or both segments are absent).</p>
<p>Each loop iteration receives one segment from each version, for as long as both versions have segments remaining:</p>
<ul>
<li>All leading separators are trimmed off both segments. Results:
<ul>
<li>1.1 = 1_1</li>
</ul>
</li>
<li>If either segment is empty after trimming separators (because it's a dangling segment), the loop breaks.</li>
<li>If one segment started with more separator characters, it's a larger version. Note that the Pacman developers believe that realistic version numbers do not have multiple separator characters in a row, and Pacman isn't designed to handle this situation perfectly. Results:
<ul>
<li>1 &lt; .1 = _1 &lt; ..1</li>
<li>1.1 &lt; 1..1</li>
<li>1.a &lt; 1..a</li>
<li>1rev &lt; 1.rev &lt; 1..rev</li>
<li>a10 &lt; a.10</li>
</ul>
</li>
<li>Alphabetic segments are sorted lexicographically, and sort before numeric segments (sorted numerically). Results:
<ul>
<li>a &lt; aa &lt; z &lt; zz &lt; 1 = 01 &lt; 9 &lt; 10</li>
</ul>
</li>
</ul>
<p>The function returns immediately if the loop finds a pair of segments that compare unequal. Otherwise the loop stops (without stripping separators) when one or both inputs reach the end of line, or breaks (after stripping separators) when one or both inputs reach a final dangling segment.</p>
<p>At this point, one of these is true:</p>
<ul>
<li>at least one version has no segment.</li>
<li>no versions have missing segments, but at least one version has a dangling segment (causing both segments to be stripped, so at least one version <em>now</em> has no segment).</li>
</ul>
<p>The segments are compared as follows:</p>
<ul>
<li>none = none</li>
<li>none &gt; alpha</li>
<li>none &lt; separator or number</li>
<li>alpha &lt; none</li>
<li>separator or number &gt; none</li>
</ul>
<p>The algorithm is complete.</p>
<p>All dangling segments compare equal to one another, but come after &quot;segment with text&quot; and &quot;no segment&quot; and before &quot;segment with number&quot;.</p>
<ul>
<li>
<p>1a &lt; 1 &lt; 1.a &lt; 1. = 1.. &lt; 1.0</p>
</li>
<li>
<p>'' &lt; '.' = '..'</p>
</li>
<li>
<p>1 &lt; 1. = 1_ = 1..</p>
</li>
</ul>
<p>Unfortunately this algorithm has a cycle, caused by how more leading separators wins a version comparison (even if followed by a losing body) if both segments have bodies, but gets ignored if one or both segments are empty after trimming.</p>
<ul>
<li>1.0 &lt; 1..a (more leading separators wins since both segments have bodies)</li>
<li>1..a &lt; 1. (leading separators ignored since 1. is empty after trimming, 'a' &lt; '')</li>
<li>
<ol>
<li>&lt; 1.0 (leading separators ignored since 1. is empty after trimming, '' &lt; '1')</li>
</ol>
</li>
</ul>
<p>Note that 1. and 1... are interchangeable, because the dangling separators get stripped out either way.</p>
<p>The Pacman developers commented, &quot;Fun example :) Like I said, having multiple delimiters in a row doesn't make a lot of sense, so that is pretty much undefined behaviour&quot;</p>
<h2 id="testing-the-requirements">Testing the requirements</h2>
<p>Dangling segments and multiple separators don't occur in real-world version numbers and can be ignored. Does this algorithm properly order real-world versions?</p>
<ul>
<li>1.0beta &lt; 1.0</li>
</ul>
<p>Yes, &quot;beta&quot; &lt; &quot;&quot;.</p>
<ul>
<li>1.0 &lt; 1.0.1</li>
</ul>
<p>Yes, &quot;&quot; &lt; &quot;.1&quot;.</p>
<ul>
<li>1.0.1 &lt; 1.0.2</li>
</ul>
<p>Yes, &quot;.1&quot; &lt; &quot;.2&quot;.</p>
<ul>
<li>1.0 &lt; 1.0.alpha</li>
</ul>
<p>Yes, &quot;&quot; &lt; &quot;.alpha&quot;</p>
<h1 id="what-is-pkgbuild-and-pkgver">What is PKGBUILD and <code>pkgver</code>?</h1>
<p>PKGBUILD files are shell scripts defining variables and functions used by <code>makepkg</code> to build a binary package. The <code>pkgver</code> variable serves as the version number of the PKGBUILD and the package produced. All PKGBUILD files contain a <code>pkgver</code> variable, storing the package's version at the time the file was written. However, this is insufficient for VCS/<code>-git</code> packages tracking the latest commit in a Git repository, where the version of software built by a PKGBUILD can change even when the PKGBUILD does not. To accommodate this, <code>makepkg</code> also supports a <code>pkgver()</code> function, which when run produces the <em>current</em> version of the package.</p>
<p>If <code>pkgver</code> is a variable only, then an unmodified PKGBUILD and <code>pkgver</code> means the package has not been updated. But if a <code>pkgver()</code> function is present, then an AUR helper trying to determine if an installed package is outdated must re-clone/pull the VCS repo listed in <code>source=(...)</code> and call <code>pkgver()</code> again, even if the PKGBUILD and <code>pkgver</code> are unmodified.</p>
<p>If a <code>pkgver()</code> function is present, then running <code>makepkg</code> to build the PKGBUILD into a binary package also rewrites the PKGBUILD file with a <em>new</em> value for the <code>pkgver</code> variable. A few fixed-version packages like <a href="https://github.com/archlinux/svntogit-packages/blob/master/qt5-base/trunk/PKGBUILD">qt5-base</a> and <a href="https://github.com/archlinux/svntogit-packages/blob/master/qt5-wayland/trunk/PKGBUILD">qt5-wayland</a> use this property by defining a <code>pkgver()</code> function to automatically recompute complex version numbers. Unlike <code>-git</code> packages in the AUR, these PKGBUILDs build a fixed version of the source code, and their <code>pkgver()</code> functions return a fixed value.</p>
<h1 id="building-a-pkgver-so-pacman-sorts-git-repositories-correctly">Building a <code>pkgver()</code> so Pacman sorts Git repositories correctly</h1>
<p>Git repositories in the wild have a lot of variance; some don't have tags, some have tags that sort properly, and some have tags in the wrong order. And some repositories start with no tags, but create tags later on when they make their first release.</p>
<h2 id="requirements-for-comparing-versions-1">Requirements for comparing versions</h2>
<p>What are the requirements for generating version numbers from a Git repository?</p>
<ul>
<li>As a repository without tags creates more commits, the version number should increase.</li>
<li>When a repository creates its first release/tag, the version number should increase.</li>
<li>As a repository with tags creates more commits, the version number should increase.</li>
<li>If the most recent tag changes from 1.0 to 1.1, the version number should increase.</li>
<li>If the most recent tag changes from 1.0 to 1.0.1, the version number should increase.</li>
</ul>
<p>How can we achieve these criteria, given how Pacman works?</p>
<h2 id="arch-wiki-templates">Arch Wiki templates</h2>
<p><a href="https://wiki.archlinux.org/index.php/VCS_package_guidelines#The_pkgver()_function">The Arch wiki</a> provides copy-paste snippets of example pkgver() functions, but fails to explain the underlying concepts (what <code>git describe</code> outputs, what the sed expression does, how the resulting expression is evaluated by <code>vercmp</code> and <code>pacman</code>).</p>
<h3 id="untagged-git-repositories">Untagged Git repositories</h3>
<p>In a Git repo where the history of <code>master</code> has no tags, the recommended <code>pkgver()</code> counts commits:</p>
<pre data-lang="sh" style="background-color:#fafafa;color:#111111;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#4078f2;">pkgver</span><span>() {
</span><span>  </span><span style="color:#0184bc;">cd </span><span style="color:#50a14f;">&quot;$</span><span style="color:#e45649;">pkgname</span><span style="color:#50a14f;">&quot;
</span><span>  </span><span style="color:#0184bc;">printf </span><span style="color:#50a14f;">&quot;r%s.%s&quot; &quot;$(</span><span style="color:#e45649;">git</span><span style="color:#50a14f;"> rev-list --</span><span>count</span><span style="color:#50a14f;"> HEAD)&quot; &quot;$(</span><span style="color:#e45649;">git</span><span style="color:#50a14f;"> rev-parse --</span><span>short</span><span style="color:#50a14f;"> HEAD)&quot;
</span><span>}
</span></code></pre>
<p>This produces a string <code>r{number of commits}.{commit hash}</code>.</p>
<p>Any letter would work equally well for the version comparison algorithm, <code>r</code> was chosen because it sounds like &quot;revision&quot;. But what is the purpose of a letter?</p>
<h3 id="tagged-git-repositories">Tagged Git repositories</h3>
<p>If the repo has tags like 0.2.5 which begin with a number (no leading &quot;v&quot; prefix like v0.2.5), <code>git describe --long --tags</code> can be used as the root source for the version:</p>
<pre data-lang="sh" style="background-color:#fafafa;color:#111111;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#4078f2;">pkgver</span><span>() {
</span><span>  </span><span style="color:#0184bc;">cd </span><span style="color:#50a14f;">&quot;$</span><span style="color:#e45649;">pkgname</span><span style="color:#50a14f;">&quot;
</span><span>  </span><span style="color:#e45649;">git</span><span> describe --long --tags | </span><span style="color:#e45649;">sed </span><span style="color:#50a14f;">&#39;s/\([^-]*-g\)/r\1/;s/-/./g&#39;
</span><span>}
</span></code></pre>
<p><code>git describe --long</code> produces a string with format <code>{most recent tag}-{commits since tag}-g{commit hash}</code>.</p>
<pre data-lang="sh" style="background-color:#fafafa;color:#111111;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#e45649;">git</span><span> checkout master
</span><span style="color:#e45649;">git</span><span> describe --long --tags  </span><span style="font-style:italic;color:#a0a1a7;"># v2.4-25-ga240b43
</span><span style="color:#e45649;">git</span><span> checkout v2.4  </span><span style="font-style:italic;color:#a0a1a7;"># or git checkout HEAD~25
</span><span style="color:#e45649;">git</span><span> describe --long --tags  </span><span style="font-style:italic;color:#a0a1a7;"># v2.4-0-g51e51f4
</span></code></pre>
<p>The sed expression turns it into <code>{most recent tag}.r{commits since tag}.g{commit hash}</code>.</p>
<h2 id="testing-the-requirements-1">Testing the requirements</h2>
<ul>
<li>As a repository without tags creates more commits, the version number should increase.</li>
</ul>
<p>&quot;r###&quot; &lt; &quot;r###+1&quot;? Trivially so, as the &quot;r&quot; segment is the same, but the &quot;number of commits&quot; segment increases.</p>
<ul>
<li>When a repository creates its first release/tag, the version number should increase.</li>
</ul>
<p>&quot;r###&quot; &lt; &quot;1.0.r###&quot;? Yes. The version of the untagged repository starts with a &quot;r&quot; segment. The version of the tagged repository starts with a numeric segment (taken from the tag), which comes after.</p>
<ul>
<li>As a repository with tags creates more commits, the version number should increase.</li>
</ul>
<p>&quot;1.0.r###&quot; &lt; &quot;1.0.r###+1&quot;? Yes. &quot;most recent tag&quot; is unchanged, &quot;.r&quot; is unchanged, and &quot;commits since tag&quot; increases.</p>
<ul>
<li>If the most recent tag changes from 1.0 to 1.1, the version number should increase.</li>
</ul>
<p>&quot;1.0.r###&quot; &lt; &quot;1.1.r###&quot;? Yes. &quot;most recent tag&quot; increases.</p>
<ul>
<li>If the most recent tag changes from 1.0 to 1.0.1, the version number should increase.</li>
</ul>
<p>&quot;1.0.r###&quot; &lt; &quot;1.0.1.r###&quot;? Yes. &quot;1&quot;=&quot;1&quot;, &quot;.0&quot;=&quot;.0&quot;, and &quot;.r&quot; &lt; &quot;.1&quot;.</p>
<h3 id="why-not">Why not &quot;.&quot;?</h3>
<p>If tag-based versions were <code>{most recent tag}.{commits since tag}...</code>, then if the most recent tag changes from 1.0 to 1.0.1, the version would change from &quot;1.0.###&quot; to &quot;1.0.1.###&quot;, where &quot;.1&quot; sorts <em>before</em> &quot;.###&quot; despite 1.0.1 being a newer program version.</p>
<p>This was first brought up by @diabonas:archlinux.org:</p>
<blockquote>
<p>You need it because otherwise 1.0.500 (where 500 is the revision count) would be newer than 1.0.1.30 (again, 30 is the revision count) - this doesn't happen with 1.0.r500, which is older than 1.0.1.r30 because a letter is always older than a digit</p>
</blockquote>
<h3 id="why-not-r">Why not &quot;r&quot;?</h3>
<blockquote>
<p>It's 1.0.1.r30 - the dot is important as 1.0.1r30 would be older than 1.0.1, but 1.0.1.r30 is newer - it's a revision after 1.0.1 after all. And yeah, 1.0r31 is a revision after 1.0, but before the next upstream release 1.0.1, whole 1.0.1.r31 is a revision after 1.0.1, so newer than 1.0.r30</p>
</blockquote>
<h2 id="the-arch-wiki-is-wrong">The Arch Wiki is wrong</h2>
<p>The Arch wiki's stated requirements for generating version numbers are:</p>
<blockquote>
<p>It is recommended to have following version format: <em>RELEASE.rREVISION</em> where <em>REVISION</em> is a monotonically increasing number that uniquely identifies the source tree (VCS revisions do this).</p>
</blockquote>
<p>The Arch wiki is wrong; given the &quot;RELEASE.RELEASE.rREVISION&quot; convention recommended by the wiki, for Pacman to properly identify older and newer packages, REVISION does not need to be globally monotonic, only within a given RELEASE. And the Arch wiki even breaks its own rules: the example &quot;Git with tags&quot; <code>pkgver()</code>'s REVISION is not monotonic except within a given RELEASE (Git tag).</p>
<p>Even if the Arch wiki was changed to say that REVISION needs to be monotonic within a given RELEASE, it states that <code>0.1.r456 &gt; r454</code> but <code>0.1.456 &lt; 454</code>, without explaining the algorithm used to compare revisions. This only serves to confuse the reader.</p>

  </div>

	

  <div class="pagination">
  	<a href="https://nyanpasu64.gitlab.io/blog/low-latency-audio-output-duplex-alsa/" class="left arrow">&#8592; Newer</a>
		<a href="#" class="top">Top</a>
		<a href="https://nyanpasu64.gitlab.io/blog/exotracker-newsletter-2-pivoting-to-snes/" class="right arrow">Older &#8594;</a>
  </div>

  </main>

  
  <footer>
    <span>Adventures in programming, DSP, and chiptune.<br>Made with <a href="https://www.getzola.org">Zola</a> using the
      <a href="https://github.com/aaranxu/tale-zola">Tale-Zola</a> theme
      (<a href="https://github.com/nyanpasu64/tale-zola">modified</a>).
    </span>
  </footer>
  
</body>
</html>
